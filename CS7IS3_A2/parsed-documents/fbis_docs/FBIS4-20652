FBIS4-20652 "jpjst015__l94031" JPRS-JST-94-015-L JPRS Science & Technology Japan 12 April 1994 FACTORY AUTOMATION, ROBOTICS An Integrated System for Concurrent Design and Analysis in An Integrated System for Concurrent Design and Analysis in Conceptual Aerospace Design Aerospace Design 43070062A Tokyo FUJITSU SCIENTIFIC & TECHNICAL JOURNAL in English Dec 93 pp 401-413--FOR OFFICIAL USE ONLY 43070062A Tokyo FUJITSU SCIENTIFIC & TECHNICAL JOURNAL English CSO [Article by Yuichi Sato, Masahito Kawai and Hiromichi Yamamoto (Manuscript received June 4, 1993); first paragraph introductory comment] [Text] This paper describes a knowledge-based system to support concurrent design and analysis. The system, DESSIA (Design Support System for Integrated Analysis) provides designers with information to analyze a problem and obtain design outputs by using the expertise accumulated in the system. The system combines a knowledge base, engineering database, and program library in an object-oriented expert shell. The system is flexible and evolutional. Programs and data can be registered, maintained, and developed with little labor, thereby providing a systematic framework for constructing and developing hierarchical databases of programs and data for concurrent design and analysis. 1. Introduction The design cycle of complex large-scale structures such as aircraft and nuclear plants, and that of missions for space stations and space robots usually has an intricate feedback structure. For instance, in the case of aircraft the design cycle begins with a number of design specifications such as payload mass, flight performance, and cost, followed by a variety of analyses for factors such as weight, aerodynamics, and propulsion. These are generally analyzed by different technical groups, which cooperate in numerous discussions based on the latest information before finally coming up with a feasible design concept. An entire project can no longer be evaluated by a single designer. This makes the designers' most important task the integration of researcher's expertise, usually expressed in the form of technical programs and data, into a single refined design concept. This work is called concurrent design and analysis. This paper presents a knowledge-based system which helps designers to perform concurrent design and analysis by accelerating communication between designers and researchers. Unfortunately, the current computer environment is insufficiently flexible for easy management and integration of technical programs and data. Underlying problems hindering efficiency fall mainly into two groups. First, integration of basic technical knowledge is typically represented by integrated engineering programs of different technical groups. For example, to analyze flight performance, which is often done in terms of flight range and flight time, at least four engineering programs--weight analysis, aerodynamics analysis, propulsion analysis, and flight performance analysis--must be combined. The resulting large, compound program can be used to analyze how a change in body structure or engine performance influences flight performance. The programs, which are developed independently, are too inflexible to be interfaced. Also, once combined into a large single program, component programs become very difficult to maintain. Second, most engineering programs have a number of input and output data items. They are usually scattered, redundant, disconnected, and jumbled because of the many independent groups involved. This wastes huge amounts of memory. Even worse, it becomes very hard to clarify data relationships and determine the most appropriate design data from the ocean of numerical values involved. All these problems restrict the problem-solving and decision-making capabilities of designers in the design cycle. The above problems have been known for more than 20 years at NASA and the Boeing Aerospace Company, and many systems have been constructed in an attempt to overcome them[.sup]1)-5)[/]. Historically, the point that determined the success of a system was its overall flexibility and maintainability. Previous approaches in which programs were connected at the source level or through databases, have been unsuccessful, mainly because of the inflexible procedural control structures in compound programs and the difficulty of ensuring consistent maintenance of compound and component programs. A few years ago, Boeing Computer Services constructed a knowledge-based system, called Expert Executive, in which programs are loosely connected through knowledge bases of input/output arguments and procedural information[.sup]6)-8)[/]. The system reportedly works better than its predecessors. However, it focuses mainly on program integration and neglects the treatment of massive amounts of data and its relation to program integration. This paper describes a knowledge-based system, called DESSIA (Design Support System for Integrated Analysis), which solves all the above problems. DESSIA is based on the following: 1) Concurrent management of programs and data The system separates programs from data as completely as possible and constructs different tree structures. The program and data trees are interrelated, and their relationship is accumulated as interface tables in the knowledge base. The purpose of this separation is to enable programs and data to be maintained separately and provide a framework for concurrent management of programs and data. 2) Semiautomatic program integration The system provides macrocommands to form a large-scale compound program by combining programs registered in the program tree. These commands logically check interface information stored as cross references between argument names in the knowledge base. Then, these commands semiautomatically determine the execution sequence of programs. Programs are not connected at the source level. Instead, they are connected through input and output argument names contained in the knowledge base. 3) Optimization of design parameters The system provides a general purpose optimization method for design parameters. Using this function, designers can obtain optimized design parameters under any constraints. This function is based on a nonlinear programming method called the complex method. To exploit the advantage of a concurrent design environment containing workstations connected through networks, this function has been extended to run in a distribution scheme. DESSIA enables comprehensive, synchronized treatment of programs and data. The program and data trees evolve independently while preserving their flexibility and maintainability. At the same time, they are closely interconnected through a chain of I/O arguments in the knowledge base. 2. Concurrent Management of Programs and Data In many of the so-called general-purpose programs, so many items must be selected to reach a function that the user is apt to give up before the function is even reached. Item selection is embedded in such a program inflexibly, making it essentially a closed compound system. These programs may be powerful for system use, but procedures are difficult to modify, for example, by connecting the system to external programs. This difficulty mainly arises because the system does open argument items in an interface to other programs. The rationale behind separating programs and data is to open up program interfaces and construct independent databases for programs and data. 2.1 Interface Table Programs and data are separated as follows. In view of the above-mentioned shortcoming in general-purpose programs, a program should have only one function. As shown in Fig. 1, all program input and output arguments are placed outside, and values are read from the input file and then written to an output file. The number of I/O files is not limited. We then provide an interface table between I/O arguments and files. For example, the total weight input argument is specified by an input file name and a sequence number in the table. The sequence number indicates the position of the total weight input argument in the input file. For array data, DESSIA provides a frame for which array dimensions are registered. Fig. 1. Interface table between I/O arguments and I/O 2.2 Program and Data Trees I/O arguments extracted from the program are distributed and registered in the categorized data tree (see Fig. 2). If the data tree has not grown enough to accommodate all I/O arguments, argument items and category blocks can easily be added. The aggregation of separated programs constitutes another tree structure, called a program tree. Fig. 2. Data tree; categorized I/O arguments. The values of each argument are accumulated in the data tree, which maintains the form of each category block. This block of actual values is called a category instance in the nomenclature of object-oriented paradigms. Note that although programs and data are registered separately in their respective trees, they are connected through argument names. Values in the data tree flow along argument names, passing through the interface table to reach program I/O files. 2.3 Effects of Separation The separation has the following effects. Assume that several programs are registered sequentially in the system (see Fig. 3). The owner of program X first looks into the data tree and identifies argument items of program X. If the data tree cannot manage all the arguments of program X, the owner of program X extends the data tree. Finally, program X is registered in an appropriate part of the program tree. This procedure is repeated. As the number of programs increases, the program tree and data tree evolve from a course to fine structure and constitute a domain-specific program library and a domain-specific engineering database. Fig. 3. Sequential registration of programs and As programs are registered sequentially, the system accumulates program and data interfaces spontaneously through the data tree. This means that once program X is registered, the data tree can automatically induce connections of I/O arguments as shown in Fig. 4. Here, initial connection means that the two programs share the same input arguments. Final-initial connection means that the output of one of the two programs is connected to an input of the other. Of course, the owner of program X does not know the structure of these interfaces in advance, but the system knows that argument i is shared in programs A and X by comparing argument names in the interface tables defined for these programs. Fig. 4. Connections of I/O arguments. 2.4 Concurrency of Program/Data Management A common method of constructing large-scale systems is to determine the interfaces between modules by designing the module structure of the system from the beginning, and then implement each module. This top-down style works quite well when there is no ambiguity in the system architecture or in any algorithm. However, it usually lacks flexibility in terms of the ability to change specifications during implementation. In contrast, DESSIA accumulates each expert's knowledge on the program and data trees in terms of domain specific programs and data from the bottom up. Experts can easily plug in or connect their own original programs and data into DESSIA without constraints. Once a program is plugged in, interfaces with other plugged-in programs are automatically set up through argument tags in a data tree. Experts can concurrently do their own design and analysis by using other programs and data in DESSIA. The only sequential (as opposed to concurrent) procedure in DESSIA is the plug-in procedure. This procedure can only be done by one person at a time, because otherwise the data tree would lack connection information between argument tags. 3. Compound Analysis 3.1 Construction of a Compound Program One of the "natural" ways to construct a large compound program with several component programs is to manually and arbitrarily provide interface programs. In contrast, in DESSIA, compound programs are obtained by "cutting" unnecessary interfaces that are automatically provided by the system. In DESSIA, the integration procedure consists of four steps (see Fig. 5). In step 1, the component programs to be integrated are selected from the program tree. The system then automatically connects these programs through the interface information of arguments. Second, in step 2, the sequence conditions for program execution are imposed. For example, A < B in Fig. 5 means that program A is executed before program B. Similarly, * < E means that program E is executed last. These sequence conditions automatically cut some of the connections between arguments. The resulting integrated diagram may still have logical inconsistencies such as internal loops or competent connections, which means that several outputs may be connected to the same input (see Fig. 5). In step 3, inconsistencies are removed from the integrated diagram by cutting unnecessary connections. Steps 2 and 3 are iterated alternately, as required, to make a complete diagram. In step 4, the system decides the execution sequence of component programs by following the argument connections in the diagram. The completed diagram is saved for later use. Note that the removal of inconsistencies in the diagram currently depends entirely on the designers' decisions. The system does not automatically construct an entire diagram unassisted, but presents materials in real time for the designers to evaluate. Hence the description "semiautomatic." Fig. 5. Compound analysis in semiautomatic program Figure 6 shows a program-integration example for the analysis of aircraft flight performance, in which five component programs are selected. The arrows indicate the output to input connections of the arguments, and lines without arrows indicate the input to input connections of the arguments. We impose the sequence condition that the descent performance program is executed last; therefore, the output of this program is the final descent performance. The system then asks which of the two connections is more appropriate for the total weight of the descent performance. This is a typical logical inconsistency; that is, an example of competent connection. The most probable decision of the designer will be that the total weight of the ascent performance program is more appropriate because of fuel consumption. After cutting either of these connections, we finally obtain a consistent diagram. Of course, if different conditions are imposed, a different diagram is obtained. When connecting the same program more than twice or constructing a highly-hierarchical compound program, we adopt a step-by-step approach. First, we construct a compound program with different component programs based on the procedure mentioned above, and regard it as one component program. We then add new or previously used component programs to the compound program repeatedly. This repetition completes the compound program construction we require. Fig. 6. Example of program integration. 3.2 Management of Compound Data Usually, in an engineering program, it is effective to classify input and output arguments based on their semantic nature. The effectiveness becomes more evident when dealing with programs having a hundred input/output arguments or more (see Fig. 7). Each block is called a category block. As mentioned in chapter 2, each category block of arguments is distributed and embedded in the data tree. This can be done in two ways. One way is to make a new category block in the data tree, and then register the corresponding arguments. The other is to find a corresponding category block from among those already registered in the data tree, and then identify each argument with the corresponding argument in the category block or add new argument items to the category block. Fig. 7. Example of categorization of massive amount of Actual data for each category block is accumulated in the form of a category block replica, called a category instance, in the data tree. The total set of input and output data for each engineering program can be specified in terms of the combination of these category instances. (see Fig. 8). Fig. 8. Combination of category instances. The categorization avoids redundancy in data. For example, if we construct a compound program as shown in Fig. 6, the system automatically assigns category blocks to each component program, with the category instances of "structure" expressing the same data in the data tree. Once a compound program is constructed, the system retains the connection of programs and the combination of category instances that relate to this compound program. This enables us to clarify the interrelationship of category instances by following the vertical and horizontal connections of category instances (see Fig. 9). In Fig. 9, the vertical connections correspond to the combination of category instances in Fig. 8. Fig. 9. Compound program and related combination of 4. Optimization of Parameters DESSIA uses an optimization module to provide the minimum or maximum values for design parameters such as weight, fuel consumption, and cost. Many methods of obtaining the (local) minimum or maximum value for a multivariable function have been investigated. These methods are classified into two general groups: mathematical programming and calculus of variations. These methods are further categorized into linear and nonlinear types (see Fig. 10). The mathematical programming methods include the notable Karmarker method[.sup]9)[/], which is linear, and the well-known Davidson, Fletcher, Powell (DFP) method[.sup]10)[/], which is nonlinear. The calculus of variations methods include Kalman's controller design formulation[.sup]11)[/]. Fig. 10. Classification of optimization methods. We decided that the complex mathematical programming method[.sup]12)[/] is the most appropriate optimization technique for DESSIA because of the following reasons: 1) Large-scale systems are, in general, very complicated nonlinear objects, and therefore, it might not be possible to describe them analytically. 2) Usually, to obtain optimal values, a number of constraints expressed by equality and inequality must be taken into account. 3) The evaluation function of optimization is not necessarily described analytically; therefore, we cannot assume that the evaluation function can be differentiated. The complex method can be applied to a very wide range of linear and nonlinear systems, both with and without an analytical object description. Also, this method can be extended to distributed computation under an environment of connected workstations. Therefore, the distributed complex method is suitable for the environment of concurrent design and analysis. 4.1 Distributed Complex Method Let us consider the following optimization problem: Minimize an evaluation function f (x[.sub]1[/], ..., x[.sub]n[/]) of n independent variables under the following inequality conditions: Using the complex method, the main procedure for the above optimization problem is as follows: 1) Take n + 1 points in an n-dimensional space. 2) Find n + 1 better points from the previous n + 1 points by calculating the evaluation function at each point. 3) Repeat step 2 until the n-dimensional polyhedron described by the n + 1 points shrinks to a small region. In the complex method, inequality conditions (1) are transformed into penalty functions P[.sub]k[/] which take the value of 0.0 when conditions (1) are satisfied, otherwise, they take a very large positive value. Then, the evaluation function f is modified by adding P[.sub]k[/]: S = f + _e_ over k P [.sub]k[/] (2) In the complex method, the modified evaluation function S is minimized instead of f. If the maximum of f is needed, the sign of f is inverted. The flowchart of the complex method is shown in Fig. 11. Each one-dimensional search is carried out by means of distributed computation, and the maximum degree of distribution is n when the number of independent variables is n. Fig. 11. Flowchart of complex method. 4.2 Example Calculation We applied the distributed complex method to obtain an optimum path for a manipulator of the Experimental Test Satellite VII (ETS-VII), which is to be launched in 1997[.sup]13)-15)[/]. Figure 12 shows a computer graphics model of this satellite. The most serious control problem regarding the ETS-VII is how to minimize attitude disturbances due to manipulator movements so that the communication link is not broken. This problem is solved by finding a manipulator path which minimizes or locally minimizes attitude disturbances. Fig. 12. ETS-VII concept. As an evaluation function, we take the maximum of feedforward angular momentum L[.sub]Wff[/] for the momentum wheels (see Fig. 13 for the notation). L[.sub]Wff[/] is given by: Fig. 13. Coordinate definition. where Q[.sub]x[/] = max (0 � t � t[.sub]F[/]) | L[.sub]Wffx[/] (t)/M[.sub]x[/] |, Q[.sub]y[/] = max (0 � t � t[.sub]F[/]) | L[.sub]Wffy[/] (t)/M[.sub]y[/] |, Q[.sub]z[/] = max (0 � t � t[.sub]F[/]) | L[.sub]Wffz[/] (t)/M[.sub]z[/] |,(5) The constraints are limits for each joint angle: _th_min i � _th_[.sub]i[/] � _th_ max i, i = 1, ..., 6 (6) ------------------------------------------------------------------------------ |Table 1. Initial input for optimization | ------------------------------------------------------------------------------ | |_th_ |_th_ |_th_ |_th_ |_th_ |_th_ | | |[.sub]1 |[.sub]2 |[.sub]3 |[.sub]4 |[.sub]5 |[.sub]6 | | |[/] |[/] |[/] |[/] |[/] |[/] | ------------------------------------------------------------------------------ |Initial j-|0.0 |0.0 |0.0 |0.0 |0.0 |0.0 | |oint angl-| | | | | | | |es (deg) | | | | | | | ------------------------------------------------------------------------------ |Final joi-|0.0 |-77.0 |60.0 |105.0 |90.0 |0.0 | |nt angles | | | | | | | |(deg) | | | | | | | ------------------------------------------------------------------------------ |Final tim-|3.667 | | |e t[.sub]F | | | |[/] (s)| | | ------------------------------------------------------------------------------ The initial inputs for the optimization are the initial and final manipulator positions, and the movement time t[.sub]F[/]. In general all paths connecting the initial and final positions should be checked to obtain the exact optimum path. However, we restrict the search region to a feasible path set in which each joint is assumed to follow a trapezoidal velocity pattern (see Fig. 14). The acceleration time t[.sub]Ai[/] and the deceleration time t[.sub]Di[/] are independent variables of the complex method. Since the ETS-VII's manipulator has 6 degrees of freedom, the maximum distribution degree is 2 x 6 = 12. Fig. 14. Joint velocity pattern. We set the physical parameters of the ETS-VII as follows: manipulator mass = 100 kg; manipulator length = 2 m; satellite main-body mass = 2 tons; and m[.sub]xx[/] = 5,000 kgm[.sup]2[/], m[.sub]yy[/] = 2,000 kgm[.sup]2[/], m[.sub]zz[/] = 5,000 kgm[.sup]2[/] for the satellite's main-body inertia. Table 1 shows the initial inputs for the optimization. The initial and final manipulator positions are shown in Fig. 15. The result of the optimization is summarized in Table 2. We used 12 S-4 workstations for the optimization (see section 5.2 for details). When the procedures were distributed between 12 workstations, the computation time was reduced to about one-tenth of the time when only one workstation was used. In this optimization, there was no delay associated with the communication link because only a few bytes of data were transmitted through the ethernet cables. Table 2. Result of optimization Joint Joint 2 Joint 3 Joint 4 Joint 5 Joint S 1 6 Initial 1/3 0.5 - E 0.5 - E 0.5 - E 0.5 - E 1/3 1.04 t[.sub]Ai[/] Initial 2/3 0.5 + E 0.5 + E 0.5 + E 0.5 + E 2/3 E = t[.sub]Di[/] 0.01 Optimized 1/3 0.1341 0.4963 0.4933 0.4928 1/3 0.2265 t[.sub]Ai[/] Optimized 2/3 0.4867 0.5066 0.5042 0.5028 2/3 t[.sub]Di[/] t[.sub]Ai[/] and t[.sub]Di[/] are normalized by t[.sub]F[/] M[.sub]x[/] = M[.sub]y[/] = M[.sub]z[/] = 40 Nms. Fig. 15. Initial path and optimized path As shown in Fig. 15, the optimized path brings the tip of the manipulator toward the center of mass of the satellite's main body and then curves it away to the final position. This is physically reasonable and holds very well in almost any situation. 5. Implementation 5.1 System architecture for program/data management Considering the easy realization of the system architecture, we have adopted an object-oriented expert shell to implement the system. We used ESHELL/X on UTI-LISP developed at Fujitsu to implement the first version of DESSIA on a mainframe computer. We then converted the system for SPARC stations using the commercial expert shell "ART" on Common Lisp. The basic idea of object-oriented systems is to define the "object," which is a unit composed of methods and properties, and create an algorithm by sending messages between objects. There are two levels of objects: class-level objects and instance-level objects. Class-level objects can be copied as instance-level objects dynamically. In DESSIA, the components of the program and data trees are expressed by instance-level objects produced by class-level objects, and the interfaces between programs and data are represented by "slot values" which are ready for the connection. Each time programs and data are registered in the system, the corresponding class-level objects produce instance objects and append them to the program and data trees. Figure 16 shows the class structure for program/data management. The classes are categorized into three groups: the program manager group, compound program/data manager group, and argument manager group. They are further divided into resident classes and others. The core of the system currently consists of more than 20 class-level objects and about 150 methods. Fig. 16. Class structure for program/data 5.2 System architecture for distributed complex method In general, there are two methods for distributed computation: tightly coupled and loosely coupled. In DESSIA, we assume an environment consisting of workstations connected by NFS. Therefore the distributed complex method was realized using a client/server model with UNIX's IPC (Interprocess Communications). Figure 17 shows the concept of the distributed computer environment for DESSIA. The manager host is the workstation which manages the local host workstations. A local host is a workstation which runs a distributed process. The terminal host is the workstation used to enter DESSIA and define an optimization calculation. In general, the manager host and terminal hosts also function as local hosts. Also, any local host can become a terminal host for a different user. Fig. 17. Client/server model for optimization in The design specifications for the distributed complex method are as follows: 1) M processes can be distributed between N local hosts. (M can be greater than N in general). 2) Users can register other workstations as local hosts. 3) Users can easily register optimization modules at any terminal host using the `plug-in' procedure of DESSIA. 4) Program/data management in DESSIA can be done on any terminal host, and the concurrency of program/data editing is handled by the manager host. Based on these specifications, we realized the following client/server processes: 1) Host Manager (HM): a server process that runs on the manager host. 2) Local Host Manager (LHM): a server process that runs on each local host and is activated by HM. 3) Prototype Process Manager (PPM): a server process that runs on the manager host and managing PPs and is activated by HM. 4) Prototype Process (PP): an object process that runs on each local host and is activated by LHM. 5) Process (P): a process that runs on each local host, executes an actual distributed object, and is activated by PP. 6) Client Process (CP): a client process that runs on the terminal host and is primarily activated by a user as required. Initially, DESSIA is awakened on the manager host by a user. Then, HM is activated on the manager host and LHM is activated on each local host. HM and the LHMs then wait for a message from a terminal-host's client process. A user then enters DESSIA at a terminal host and wakes up a client process, which then does the following: 1) Asks HM to wake up PPM and PPs through the LHMs. 2) Asks PPM to set the initial inputs for each PP. 3) Asks each PP to wake up Ps. (The total number of Ps is M.). 4) Waits for a computed result from each P. 5) Releases the finished Ps. We assume that all terminals and local workstations have the same versions of OS and libraries. If the versions are not the same, execution modules for the complex method must be recompiled beforehand at a local workstation. 6. Conclusion We have analyzed some of the problems in the computer environment surrounding designers whose role is to integrate the programs and data that express the expertise of researchers. We have developed a knowledge-based system to support these designers. This system is evolutional. As the programs and data are registered, the program and data trees in the knowledge base become proportionally larger. Combining programs in the program tree enables a large-scale compound program to be built without programming. The resultant execution data is arranged in the data tree, which can be regarded as an engineering database interconnected with a chain of I/O arguments. We introduced the complex method into DESSIA as an optimization tool to obtain the maximum or minimum of any nonlinear function. We extended this method into a distributed complex method to suit the network environment. Preliminary experiments showed that the distributed complex method reduced the computation time almost in proportion to the number of workstations. Improvements planned for the near future include: 1) Implementation by C[.sup]++[/] In view of the current trend for object-oriented programming, implementation by C[.sup]++[/] instead of a Lisp-based expert shell will provide more flexibility and compatibility. 2) Scheduling of distributed computation Computation efficiency will be improved by scheduling the degree of distribution based on the workstations' CPU power and occupancy. 3) Graphical human-machine interface A flexible graphical HMI such as GUI Builder will make it relatively easy to construct large-scale compound programs on DESSIA, as shown in Fig. 18. Fig. 18. HMI image for DESSIA 7. Acknowledgment We would like to thank Mr. Koichi Matsusima and Mr. Masao Naka of the National Aerospace Laboratory for the many valuable discussions we had with them. References 1) Glatt, C. R., Hague, D. S., and Watson, D. A.: DIALOG: An Executive Computer Program for Linking Independent Programs. NASA CR-2296, 1973. 2) Glatt, C. R., and Hague, D. S.: ODIN: Optimal Design Integration System. NASA CR-2492, 1975. 3) Wilhite, A. W., and Rehder, J. J.: AVID: A Design System for Technology Studies of Advanced Transportation Concepts. AIAA 79-0872, 1979. 4) Walker, W. J., Vos, R. G., Price, G. A., and Brogren, E. W.: IAC Executive summary. NSA CR-175196, 1984. 5) Meyer, D. D.: Development of Integrated Programs for Aerospace-Vehicle Design (IPAD) Reference Design Process. NASA CR-2981, 1984. 6) Chalfan, K. M.: An Expert System for Design Analysis. Workshop on Coupling Symbolic and Numerical Computing in Expert System, 1985. 7) Chalfan, K. M.: A Knowledge System Which Integrates Heterogeneous Software for a Design Application. Proc. JSST Int. Conf. Tokyo, 1986. 8) Chalfan, K. M.: A Generic Tool for Integrating Software Components. Proc. CIPS, Edmonton, 1987. 9) Karmarker, N. K.: A New Polynomial-Time Algorithm for Linear Programming. Proc. from the ACM Symp. Theory Computer, 1984, pp 302-311. 10) Fletcher, R., and Powell, M. J. D.: A rapidly convergent descent method for minimization. J. Optimization Theory and Applications, 6, pp 163-168 (1963). 11) Kalman, R. E.: Contributions to the theory of optimal control. Vol. Soc. Mat. Mex.,, 5, pp 102-119 (1960). 12) Box, M. J.: A New Method of Constrained Optimization and a Comparison with other Methods. Computer Journal, 8, 1, (1965). 13) Oda, M.: Space Robotics On-Orbit Experiments by ETS-VII. (in Japanese), Proc. 9th RSJ Annual Conf., 1311, 1991, pp 75-78. 14) Oda, M., Wakabayashi, Y., Ichikawa, S., Imai R., and Anzai, T.: ETS-VII, The World First Telerobotic Satellite (Mission and its Design Concept). Proc. 1992 i-SAIRAS, 1992, pp 307-315. 15) Sato, Y., Hirata M., Nagashima, F., Maruyama, T., and Uchiyama, T.: Reducing Attitude Disturbances while Teleoperating a Space Manipulator. Proc. 1993 IEEE Robotics and Automation Conf., 3, 1993, pp 516-523.
