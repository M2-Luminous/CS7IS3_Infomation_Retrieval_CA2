FBIS4-22982 "jpust005__l94025" JPRS-UST-94-005l JPRS Science & Technology Central Eurasia 06 April 1994 COMPUTERS A Programming Language with an Expanded Grammar A Programming Language with an Expanded Grammar 937G0083A Kiev KIBERNETIKA I SISTEMNYY ANALIZ in Russian No. 3, Mar 93 (manuscript received 6 Mar 93) pp 147-155 -- FOR OFFICIAL USE ONLY 937G0083A Kiev KIBERNETIKA I SISTEMNYY ANALIZ Russian CSO [Article by V.V. Gusev, T.N. Galagan, V.V. Yaremenko; UDC 681.3.06] [Text] Introduction We would like to emphasize certain aspects of the history of the development of modeling languages in accordance with the accepted classification of its stages and trends.[.sup]1[/] Modeling languages are recognized to have made a significant contribution to the development of programming languages. By the late 60's, mainly due to the authors of SIMULY-67, requirements were formulated for universal programming languages so that they could be used to model systems with discrete events. In the 70's, this achievement sparked subsequent efforts to enrich and combine languages in order to include new classes of systems which could be modeled. An example is combined (discrete-continuous) systems with a dynamically tuned structure. The NEDIS system[.sup]2,3[/] was developed by Academician V.M. Glushkov to model this type of system, and was used intensively in dozens of design organizations. This was a period when modeling language developers were resolving their internal methodological problems, and their successes in creating means of generating simulation programs to calculate the trajectories of systems in some time period derived from engineering use of pure mathematics. However, subsequent extensive experience in using the NEDIS system and user interaction with the system led to the formulation of a number of critical conclusions (see for example Reference 4) which reflected new trends in the automation of design: - design was increasingly recognized to be a complex activity involving simulation and other calculation methods, with a key role played by methods based on algebraic description, expert systems, databases, etc.; it was felt that the transfer and conversion of information in the transition from one method to another should be completely automated; - the languages which were being used did not have the declarative capabilities to specify the system model, a plan of statistical experiments, and other formal objects of the design process as the break was made from an unambiguously understood method of interpreting them, and thus could not serve as the basis for evaluation and validation of the properties of the system and other methods of interpreting the texts of specifications. The 80's are characterized by a switch to the development of integrated design systems distinguished by a certain completeness of the methods used and a much more convenient user interface. The more specialized and more stable the area of application to which they were applied, the better these systems were. At the same time, these systems were poorly developed. The problem arose of timely development of specialized systems, and consequently, the problem of developing the corresponding tools also arose. One would hope that a new stage in the development of languages would lead to the development of the following capabilities: - adaptability to dialects of professional groups of users (the features of declarability depend substantially on the ability to use ``small'' languages[.sup]5[/] that closely correspond to the subproblem to be solved); - the ability to support various programming paradigms (in contrast to publications like References 6 and 7, page 281); for us, ``supporting a paradigm'' means having the ability to effectively develop paradigms on the basis of some fundamental version; - the combination of different methods of research and design in a single system, that is, based on clearly recognized interfaces between them; - a flexible combination of the processes of interpretation and compilation. A language with these characteristics might become an adequate technological basis for the construction of interactive integrated systems which are open to expansion with the contents of interacting functional subsystems, which would share a single database and differ in their methods of description and processing. This article presents a draft of the NEDIS-90 programming system developed by the authors. The system attempts to solve some of the aforementioned problems. The following section presents a brief overview of the system's programming language. The possibility of using the language for modeling is discussed. Finally, the current state of work to implement the system and plans for subsequent development are discussed. Modules Programs are assembled from modules, which are compilation units. In this case a module usually has a more simple structure than in other languages. In a very simple case the text of the module looks like a series of operators without any branching. In the most general case it consists of a sequence of ``descriptive'' and ``executed'' segments. A module is a variation on the concept of the block: <graphic> </graphic> The required initial sequence of operators is considered the unheaded segment EXEC. The segments GLOB and LOC are intended to describe classes, objects, procedures, and exceptions. Descriptions of GLOB segments are public, visible even to other modules. Descriptions of LOC segments are completely localized to the given module. Implementation of classes and procedures may be presented in WHERE segments, and ON segments are intended to describe procedures of reactions to exceptions. A module is executed statically in part in the compilation stage, and partially dynamically in the program. The static actions are described in INIT segments. The dynamic actions of the module are divided into preliminary (EXEC segments) and final (TERM segments) actions for mutual ordering of the execution of modules in a program. Segments of any type may be presented in an arbitrary order which is convenient for the programmer, with the only condition that they be labeled before they are used. Descriptions of new concepts have a form similar to that used in Pascal: description = label -- descriptor Descriptors define the type of the new concept, and may contain information about its initialization. We limit ourselves to the simple example of description of a class of complex numbers, a generator function, and an object of this class: <graphic> </graphic> As we can see, the body of the class of complex numbers in braces is also a block. In this case it consists only of the GLOB segment, the descriptions of the fields re and im, which are visible in the current module beyond the limits of the body of the class, and which may be used in generally accepted constructions like z.re. The generator function block consists only of an unheaded EXEC segment. Procedure-functions return the object called result. In accordance with the concepts of data abstraction the internal device of class is not considered visible in other modules, and to define the real part of a complex number we need to introduce the special function Re(z): <graphic> </graphic> In the first example the class descriptor complex includes its implementation. Here we demonstrate the possibility of separate ``preliminary'' description and specification of the implementation. The key word static is included in the descriptors of static procedures and objects which do not change state in the process of program execution. The example which is presented may be seen as the beginning of the design of a new specialized language of complex calculations. The global labels which are introduced in it may also be used in other modules, for which the current module will be called contextual. On the other hand, several initial concepts are used to specify the current module, for example, the class real. The list of initial functions for the programmed module is always defined by a list of contextual modules indicated for it. We note that the names of contextual modules are not included in the text of the current module and are communicated to the compiler as a separate parameter. This makes it possible to organize the programming system so that the selection of a list of contextual modules, and consequently, the programming language, is done automatically, proceeding from the professional profile of the user. Even more interesting is the ability to use in a module various sets of contextual modules if the system of labels that they introduce is invariant. As a result, one can state that this module is no more than some specification of a system or task, and it may have several interpretations. For example, for a single description of an electronic device, placing it in a different context one can synthesize a structural schematic, verify that certain limits are met, execute logical modeling, etc. As a result of compilation of the initial module in accordance with some list of contextual modules one develops a new contextual module which includes both object code for the program assembler and syntax compiler tables to process future modules. The module may not introduce new global definitions. In this case one will obtain a common object module whose purpose is to execute some data processing in the program which includes it. On the other hand, a module may be completely intended to introduce labels of concepts of some specialized language, and may not include executable codes. Any contextual module ``remembers'' the names of its parent contextual modules. Thus, the library of contextual modules is constructed as an oriented acyclical graph. In order to assemble a program, one does not need a project-file; it is sufficient to indicate the name of some key (junior) module, and the remaining modules, its ancestors, will be included using references to the parent modules. The execution of modules in a program is ordered in accordance with the following recursive rule: the execution of the EXEC and TERM segments of a given module begins with the one-time execution of the EXEC segments and ends with the one-time execution of the TERM segments of parent modules. Thus, the execution of any module in a program begins when the necessary tuning has already been done, and after it is finished, completion processing automatically follows. Built-In Modules and Mobility There is a set of built-in contextual modules which are terminal nodes of the oriented graph of the library, and initially fill it. They describe the description tools of a machine (real or virtual) to implement the programming system. For example, the aforementioned class real and the operations corresponding to it are components of a sublanguage defined by the built-in contextual module ARIPH. Below we present several other built-in modules: <graphic> </graphic> As one can see, we do not consider built-in data types, operations, or even control structures to be part of the basic NEDIS-90 language. Information about them is not concentrated in the compiler, and it is relatively easy to change its orientation to another machine language. The implementation machine is oriented toward the C language, which defines the content of the built-in contextual modules. A system programmer making the first steps into an ``empty'' system is in the position to use a C-like programming language. The machine which has been selected is very close in its capabilities to a traditional processor and generally accepted operating system. In its orientation toward direct generation of codes the built-in contextual modules do not require significant corrections, but rather implementation of a more exotic logic deduction processor or LISP processor for an implementation machine. In any case our problem is to compare an implementation machine as closely as possible to the filling of built-in conceptual modules. Then the programming system can be used to adjust to the area of application, beginning with the machine command level. This tuning can be done as effectively as possible. This does not require any interpreter or a library of system functions created outside the programming system with another technology. Nonetheless, the problem of the mobility of a software language, if it is posed, may be solved by reprogramming the secondary contextual modules which it specifies on the basis of built-in machine-dependent modules. Data Types A module may define three varieties of objects: static, dynamic, and stored. Static and stored, and sometimes dynamic objects, are initialized at the compilation stage. INIT segments may include algorithms of any level of complexity and freely modify their state. However, later, at the program execution stage, static objects may not be modified, and are considered constants. Complete monitoring of attempts to modify constants is implemented, as is monitoring of types, statically. Constants of typical built-in classes (whole numbers, lines, etc.) are considered static objects, and their traditional labels are visible in any module. However, due to the reloading which is permitted they may be used like any other identifiers, in particular, to label user class objects. By the beginning of module execution stored objects automatically reset the state acquired as a result of the previous run of the module in this or another program. There is no access to stored objects outside the module in which they are defined, and consequently, control of their integrity is completely in the hands of the module developer. Stored objects are primitive tools for constructing subsystems and database control languages. All objects have a life time which is not directly linked with the exit from the description block. The safety of pointers is insured by trash collection tools. This is particularly important for areas of application associated with delayed (lazy) calculations, when access to objects may be preserved after one leaves their description block due to established dependences. Effectiveness Issues The NEDIS-90 language is oriented toward the generation of effective programs on the level provided by C language compilers. The experience of constructing complex programs like compilers or modeling programs has shown that they frequently include a large initial tuning code.[.sup]8[/] In order to reduce initialization expenditures, one could implement statically defined calculations in the compilation phase; however, generally used high-level languages do not permit one to do this, limiting static calculation to built-in types and operations. The introduction of INIT segments makes it possible to generate a special program of arbitrary complexity to initialize the data of the object modules. An optimization examination recognizes statically defined expressions in all other segments and moves them into an initialization program. Object-oriented programming has stimulated users to develop a large number of small procedures. Overhead in the execution of calls and context switching can be avoided in some cases if one uses an open procedure substitution. Thus, the majority of procedures presented in the examples are better defined as open procedures. Pointers have a rather complex structure in NEDIS-90 to provide tools for dynamic monitoring of types, usually in connection with virtual procedures. However any time it is possible the compiler uses the simple format of pointers in C. Finally, the closeness of built-in contextual modules to machine implementation tools also makes it possible for the user to completely control the implementation method of problem-oriented languages. Introduction of Labels and Their Possible Forms NEDIS-90 has rather traditional tools for the development of problem-oriented data types and operations based on object-oriented programming techniques (classes as user types, encapsulation, class inheritance, virtual procedures). What is unusual is the ability to develop problem-oriented labels for them. Actually the language may be seen as a metasystem which permits one to define the syntax of almost any system of labels used in some professional language. There is no need to use the Backus-Naur metalanguage or similar metalanguages to give the form of labels. The proposed method is more like compilation of a syntax map on the left side of the description: <graphic> </graphic> Alphanumeric, sign, and literal lexemes are differentiated. Alphanumeric lexemes begin with letters or numbers. Literal lexemes are written as sequences of graphic symbols in quotes. Lexemes of all three types are equivalent and have no predefined role. Labels consist of arbitrary sequences of lexemes of any type, as well as, if necessary, specifications of parameters in square brackets. There are no limits on the order of introduction of lexemes or parameters. Functions may have a canonical form, the form of an infix operation, or any other form. One can assign operation priorities. Labels of functions may include specification of default values of parameters, variable lists of single-type parameters, and the parameter-generators of structural objects. In all cases complete static monitoring of types is provided. Let us present an example of the description of a function with a variable list of parameters. <graphic> </graphic> and a call of the described function: min(3, 5, 2, 11); The list of arguments 5, 2, and 11 forms a file which corresponds to the formal parameter y. The expression y# calculates the size of the file. One can reload labels, changing both the type of arguments and the type of result. For example, both varieties of assignment are provided by the built-in module ARIPH <graphic> </graphic> which makes it possible to make the following assignment: i = j = k. The compiler considers the actual system of implicit transformations, which is partially built-in, and which is partially determined by the user program, for example, with a function which generalizes a real to a complex number: <graphic> </graphic> Parameters can be passed by value, by reference, or by name. The simplest argument, in the form of the name of a complex variable, can correspond to the following types of parameters: <graphic> </graphic> Let us examine an example of the definition of a loop operator using all three forms of parameter passing: <graphic> </graphic> Implementation of the FOR operator uses a call to the procedure UPTO with an argument expression in the form of a call of the LOOP procedure, the simplest built-in variety of an infinite loop. This case is interesting in that the expression is parametric. The corresponding formal parameter, which is labeled as greater, is the object of the built-in class of outputs (exceptions) and is used as a marker to leave the loop. The definition of the UPTO operator is very simple: <graphic> </graphic> The body of this procedure introduces the exception break. Its generation within the parameter-procedure body leads to immediate exit with completion of the reaction procedure (which in this case is empty). Expressions with parameters, or lambda variables, are especially important in programming applications with functional or logical styles of programming. The examples which have been presented use tools which are defined by built-in contextual modules, and which demonstrate the ability to design one's own programming language. They were selected so that they would be understandable for programmers, and would not require a great deal of explanation, as in the case of a modeling language or another problem-oriented language. The basic language is the only thing which should be studied by all users in common. We note that it does not include built-in classes and procedures, and serves only to develop problem-oriented languages. Thus, it is significantly smaller than a number of other programming languages. At the same time the use of a problem-oriented language requires additional study of specific concepts which are defined by the corresponding contextual module. Of course this is also true for built-in contextual modules. Can one consider NEDIS-90 a true metasystem? Actually, it has serious limits in the construction of user languages. In particular, the following are impossible: - proposal of one's own compilation unit structure; - changing the format of descriptions; - controlling the method of separating literals in the text of a module, as well as other labels with an a priori sense, as occurs, for example, in languages with variables without preliminary declarations; - input of one's own rules for the visibility of labels. Attempts to introduce such tools are possible,[.sup]9[/] but may disrupt the relative simplicity of the language and the illusion of preserving traditional approaches. Opportunities for Use in Modeling NEDIS-90 was developed with constant checking of its elements for correspondence to the problems of designing various problem-oriented languages, especially for automation of design. The authors were interested in the modeling of combined, or discrete-continuous systems. Our problem was to provide the new system with the ability to construct a modeling language while conserving the main advantages of the old NEDIS language: - event and process methods of constructing models; - description of continuous dependences in the form of common differential equations; - no limits on the possibility of alternating fragments which establish discrete and continuous dependences if the internal logic of the text of the model requires this; - automatic ordering of the solution of the Cauchy problem (equation sorting), in spite of the modular construction of the program and dynamic reconfiguration of the modeled system; - dynamic generation of continuous blocks with common tools for generating copies of classes. At the same time, the new system has a number of advantages. Developing individual languages (to control experiments, process results, etc.) one can divide a program into functional modules, as is proposed in Reference 10. The process method of constructing models is based on the built-in concept of a coprogram with an explicit naming system. In addition to the generally accepted resume operator to switch coprograms, the built-in contextual module TASK also defines an operator of asynchronous execution of procedures in the stack of the indicated coprogram: plan [*task] for [proc] -- static proc; The plan operator makes it possible to model interruption of coprograms. When a coprogram is reset the indicated procedure is executed first, then after it is normally completed it returns to the interrupt point. Generation of an exception makes it possible to move down in the activations stack to the trap with the specified reaction. State of Development and Future Goals At publication, the implementation of the NEDIS-90 compiler with generation of programs in C for IBM PC compatible computers is complete, and is being comprehensively tested. The main difficulty has been implementation of a dynamic syntax analyzer which is capable of adapting to the intervention of users in the definition of the grammar.[.sup]11[/] Our initial plans were to place limits on the language defined by the user to insure irreversible recognition. It turned out that to formulate these limits and to verify their execution was too difficult. (Footnote) (One should not confuse this with the possibility of verifying[.sup]12[/] that the grammar belongs to class LR(k) for a given k.) Moreover, we always found interesting problem-oriented languages in conflict with the working draft of the limits system. Thus, the final version of the syntax analyzer provides parallel examination of the alternatives using a bottom-up method. Consequently, the implementation of several potential useful properties of the language have been simplified, for example, reloading of the labels of functions by the type of results. At the same time, this recognition scheme is very sensitive to the number of implicit transformations given; because there are not goals it tries to use them an excessive number of times. There are two main types of errors for the syntax analyzer: - unrecognized syntax construction; - ambiguous recognition. The latter is the analog of a ``multiply described identifier'' error in other languages, and may be the result of incorrect assignment of the system of implicit transformation or reloading of labels. Unfortunately, the resulting speed of recognition is on the order of 1200-3600 lines per minute on a computer with a clock speed of 12 MHz, which is not as high as in industrial compilers. The next step should be development of an interactive technological programming environment in NEDIS-90. Its distinguishing feature should be openness. This means that any new program should not differ from pre-existing components such as the compiler, dynamic debugger, or text editor. All of them must be controlled by a uniform user interface and have access to separate control data of the environment. This requires a special assembler which is capable of adjusting pointers with a consideration of the location of resident programs and data.[.sup]13[/] In order to free the constructors of interactive applications from the routine need to create syntax analyzers for user input, it is proposed that the compiler and assembler be implemented in the form of a special built-in contextual module. One of the most interesting issues for discussion, which is beyond the scope of this article, is the use of the NEDIS-90 language to construct languages in the declarative style of programming and its use in artificial intelligence. Let us briefly outline the basic points of the plan to expand the language by introducing built-in tools for the processing of terms, objects of a special class whose values are coded by expressions. Compared to a formal parameter like a term, an argument expression is passed to the compiler only in the syntax analysis phase. Instead of generating machine commands the recognition tree switches to the program execution stage, where it can be converted with built-in term operations. By programming some ``deduction machines'' in a number of cases one can obtain the solution of a problem as a result of pure ``transcription'' of terms. At the same time, one should provide a built-in function to generate a procedure segment using a term value if this corresponds to the calculated expression. In conjunction with the developed opportunities to use stored data, this makes it possible for the user to actively define the balance of compilation and interpretation processes. The properties of the procedural paradigm, which is the basis for built-in contextual modules, should not prevent the development of other styles of programming. For example, disruption of an assignment is not a pre-defined operation for objects of any class. It is introduced only for object-variables of standard types and when necessary can be described explicitly for user classes of objects. Procedures (and terms) will be seen only as built-in varieties of the concept of a generalized function with a predetermined interpretation. The user has the right to define his own classes of functions. At present the problem of the conflict of functional completeness of term processing tools and the limits which proceed from the requirements of static control of types is being examined. Conclusion The idea of a universal programming language had long been an attractive one, until it became clear that a key issue was not the infinite increase in the number of tools, but a generalization of expansion methods and specialization. The practice of specialization is now omnipresent, but it does not exist as a technology supported by a single programming system. The NEDIS-90 programming language presented here is intended to create program systems with certain problem-oriented languages. This is a common compiled object-oriented language providing the possibility of constructing user types and operations on the basis of known types and operations. It includes the opportunity to define a language syntax suited to the problem area, but cannot itself contain any built-in type and operation descriptions. Implementation of a problem-oriented language is registered in the program system as a contextual module. The basis consists of built-in contextual modules. They correspond to the level of tools of the implementation machine. The initial module may contain calculation fragments which are as complex as desired, and these are executed at the compilation stage. As a result, all objects described at the module level may be initialized at compilation time. The language permits work with stored objects to program database control tools. A special built-in contextual module defines the primitives of the coprogram implementation needed to construct modeling languages and parallel execution of programs. References 1. P. Kiviat, ``Simulation, Technology and Decision Process,'' ACM TRANS. MODELING AND COMPUTER SIM. Vol. 1 No. 2, 1991 pp 89-98. 2. V.M. Glushkov, V.V. Gusev, T.P. Maryanovich, et al., Programmnyye sredstva dlya modelirovaniya nepreryvno-diskretnykh sistem [Software Tools To Model Continuous-Discrete Systems], Kiev: Nauk. dumka, 1975 152 pp. 3. S.S. Azarov, V.V. Gusev, T.P. Maryanovich, et al., ``Simulation with Tools in the NEDIS and GASP-IV Systems,'' KIBERNETIKA No. 3, 1980 pp 35-50. 4. V.V. Kalashnikov, ``Aggregative Systems: Modeling, Mathematical Analysis, Simulation,'' SYST. ANAL. MODEL. SIM. Vol. 8 No. 7, 1991 pp 507-514. 5. E. Ipser, ``Exploratory Language Design,'' ACM SIGPLAN NOTICES Vol. 27 No. 4, 1992 pp 41-50. 6. J. Placer, ``Integrating Destructive Assignment and Lazy Evaluation in the Multiparadigm Language G-2,'' ACM SIGPLAN NOTICES Vol. 27 No. 2, 1992 pp 65-74. 7. J.A. Goguen, J. Meseguer, ``Models and Equality for Logical Programming,'' LECT. NOTES COMP. SCI. Vol.250, 1987 pp 1-22 (Russian transl. in book Matematicheskaya logika v programmirovanii: Sb. statey [Mathematical Logic in Programming: A Collection of Articles], Moscow: Mir, 1991 pp 274-310). 8. M. Sabatella, ``Lazy Evaluations of C++ Static Constructors,'' ACM SIGPLAN NOTICES Vol. 27 No. 6, 1992 pp 29-36. 9. H. Christiansen, ``Adaptable Grammars,'' ACM SIGPLAN NOTICES Vol. 25 No. 11, 1990 pp 35-44. 10. D. Sanderson, R. Sharma, R. Rozin, et al., ``The Hierarchical Simulation Language HSL: A Versatile Tool for Process-Oriented Simulation,'' ACM TRANS. MODELING AND COMPUTER SIM. Vol. 1 No. 2, 1991 pp 113-153. 11. S. Cabasino, P.S. Paolucci, G.M. Todesco, ``Dynamic Parsers and Evolving Grammars,'' ACM SIGPLAN NOTICES Vol. 27 No. 11, 1992 pp 39-48. 12. D. Knuth, ``On the Translation of Languages from Left to Right,'' INFORM. AND CONTROL Vol. 8, 1965 pp 607-639 (Russian transl. in book Yazyki i avtomaty. Sb. statey [Languages and Automata. A Collection of Articles], Moscow: Mir, 1975 pp 9-42. 13. N. Wirth, ``The Programming Language Oberon,'' SOFTWARE-PRACTICE AND EXPERIENCE Vol.18 No. 7, 1988 pp 671-690.
